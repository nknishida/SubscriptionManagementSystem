from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone
from django.utils.timezone import now
from django.contrib.auth.models import AbstractUser
from django.core.exceptions import ValidationError

class User(AbstractUser):
    email = models.EmailField(unique=True)
    username = models.CharField(max_length=150, unique=True)

    profile_picture = models.ImageField(upload_to='profile_pics/', null=True, blank=True)
    department = models.CharField(max_length=100, blank=True, null=True)
    
    # role= models.CharField(max_length=100, blank=True, null=True)
    # status= models.CharField(max_length=100, blank=True, null=True)
    phone = models.CharField(max_length=20, blank=True, null=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username']

    def __str__(self):
        return self.email

class Provider(models.Model):
    provider_name = models.CharField(max_length=255, unique=True)
    contact_email = models.EmailField(unique=True)
    contact_phone = models.CharField(max_length=20, blank=True, null=True)
    website = models.URLField(blank=True, null=True)

    def __str__(self):
        return self.provider_name

class Subscription(models.Model):
    CATEGORY_CHOICES = [
        ('software', 'Software'),
        ('billing', 'Billing'),
        ('server', 'Server'),
        ('domain', 'Domain'),
    ]

    PAYMENT_STATUS_CHOICES = [
        ('paid', 'Paid'),
        ('pending', 'Pending'),
        ('unpaid', 'Unpaid'),
    ]

    STATUS_CHOICES = [
        ('active', 'Active'),
        ('expired', 'Expired'),
        ('canceled', 'Canceled'),
    ]

    subscription_category = models.CharField(max_length=50, choices=CATEGORY_CHOICES)
    user= models.ForeignKey(User, on_delete=models.CASCADE, related_name='subscriptions')
    provider = models.ForeignKey(Provider, on_delete=models.CASCADE, related_name='subscriptions')
    subscription_id =models.IntegerField()
    start_date = models.DateField()
    end_date = models.DateField()
    billing_cycle = models.CharField(
        max_length=20, 
        choices=[
            ('monthly', 'Monthly'),
            ('quarterly', 'Quarterly'),
            ('yearly', 'Yearly'),
            ('one-time', 'One-Time')
        ],
        default='monthly'
    )
    renewal_date = models.DateField()
    cost = models.DecimalField(max_digits=10, decimal_places=2)
    payment_status = models.CharField(max_length=50, choices=PAYMENT_STATUS_CHOICES)
    payment_method = models.CharField(
        max_length=50, 
        choices=[
            ('credit_card', 'Credit Card'),
            ('debit_card', 'Debit Card'),
            ('paypal', 'PayPal'),
            ('bank_transfer', 'Bank Transfer'),
            ('other', 'Other')
        ]
    )
    last_payment_date = models.DateField(null=True, blank=True)
    next_payment_date = models.DateField(null=True, blank=True)
    status = models.CharField(max_length=50, choices=STATUS_CHOICES)
    created_at = models.DateTimeField(auto_now_add=True)
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, related_name='created_subscriptions')
    updated_at = models.DateTimeField(auto_now=True)
    updated_by= models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, related_name='updated_subscriptions')
    auto_renewal = models.BooleanField(default=False)  # Checkbox for auto-renewal
    # notes = models.TextField(blank=True, null=True)  # Additional notes

    is_deleted = models.BooleanField(default=False)  # Soft delete flag
    deleted_at = models.DateTimeField(null=True, blank=True)  # Store delete time

    def soft_delete(self):
        """Mark as deleted instead of actually deleting."""
        self.is_deleted = True
        self.deleted_at = now()
        self.save()

    def restore(self):
        """Restore the subscription from the recycle bin."""
        self.is_deleted = False
        self.deleted_at = None
        self.save()

    def clean(self):
        if self.end_date and self.start_date and self.end_date < self.start_date:
            raise ValidationError("End date cannot be earlier than the start date.")

class SoftwareSubscriptions(models.Model):
    subscription = models.OneToOneField(Subscription, on_delete=models.CASCADE, related_name='software_detail')
    software_name=models.CharField(max_length=255)
    version = models.CharField(max_length=50, blank=True, null=True)
    features = models.TextField(blank=True, null=True)
    license_type=models.CharField(max_length=255)
    no_of_users=models.IntegerField()

    def __str__(self):
        return f"Software Details for {self.subscription.id}"
    
class Utilities(models.Model):
    subscription = models.OneToOneField(Subscription, on_delete=models.CASCADE, related_name='billing')

    BILLING_TYPE_CHOICES = [
        ('Prepaid', 'Prepaid'),
        ('Postpaid', 'Postpaid'),
    ]

    PREPAID_UTILITY_TYPE_CHOICES = [
        ('Internet', 'Internet'),
        ('Mobile', 'Mobile'),
    ]

    POSTPAID_UTILITY_TYPE_CHOICES = [
        ('Electricity', 'Electricity'),
        ('Water', 'Water'),
    ]

    billing_type = models.CharField(max_length=50, choices=BILLING_TYPE_CHOICES)
    utility_type = models.CharField(max_length=50)
    location =models.CharField(max_length=50)
    account_number = models.CharField(max_length=50)

    def clean(self):
        """ Ensure subcategory matches the billing type. """
        if self.billing_type == 'Prepaid' and self.utility_type not in dict(self.PREPAID_UTILITY_TYPE_CHOICES):
            raise ValidationError("Invalid subcategory for Prepaid billing type.")
        if self.billing_type == 'Postpaid' and self.utility_type not in dict(self.POSTPAID_UTILITY_TYPE_CHOICES):
            raise ValidationError("Invalid subcategory for Postpaid billing type.")

    def __str__(self):
        return f"Billing for {self.subscription.subscription_category} - {self.billing_type} ({self.utility_type})"

class Domain(models.Model):

    DOMAIN_TYPE_CHOICES = [
        ('.com', '.com'),
        ('.in', '.in'),
    ]

    subscription = models.OneToOneField(
        'Subscription', on_delete=models.CASCADE, related_name="domain"
    )
    
    domain_name = models.CharField(
        max_length=255, unique=True, help_text="Fully Qualified Domain Name (FQDN)"
    )
    
    domain_type=models.CharField(max_length=255,choices=DOMAIN_TYPE_CHOICES)
    
    ssl_certification = models.BooleanField(
        default=False, help_text="Indicates if SSL is enabled for the domain"
    )
    
    ssl_expiry_date = models.DateField(
        blank=True, null=True, help_text="SSL certificate expiration date"
    )
    
    whois_protection = models.BooleanField(
        default=False, help_text="WHOIS privacy protection enabled or not"
    )
    
    domain_transfer_status = models.CharField(
        max_length=50,
        choices=[
            ('locked', 'Locked'),
            ('unlocked', 'Unlocked'),
            ('pending_transfer', 'Pending Transfer'),
        ],
        default='locked',
        help_text="Current status of domain transfer"
    )

    # created_at = models.DateTimeField(auto_now_add=True)
    # updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.domain_name
    
class Servers(models.Model):
    subscription = models.OneToOneField(Subscription, on_delete=models.CASCADE, related_name="server")
    
    SERVER_TYPE_CHOICES = [
        ('In-house', 'In-house'),
        ('External', 'External'),
    ]
    # STATUS_CHOICES = [
    #     ('active', 'Active'),
    #     ('inactive', 'Inactive'),
    # ]

    server_name = models.CharField(max_length=255)
    server_type = models.CharField(max_length=50, choices=SERVER_TYPE_CHOICES)
    server_capacity = models.IntegerField(
        help_text="Total resource capacity (e.g., CPU, RAM, storage)."
    )
    # status = models.CharField(max_length=50, choices=STATUS_CHOICES)
    # created_at = models.DateTimeField(auto_now_add=True)
    # updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.server_name
    
class Customer(models.Model):
    # STATUS_CHOICES = [
    #     ('active', 'Active'),
    #     ('inactive', 'Inactive'),
    #     ('pending', 'Pending')
    # ]

    CUSTOMER_TYPE_CHOICES = [
        ('inhouse', 'In-house'),
        ('external', 'External'),
    ]
    
    customer_name = models.CharField(max_length=100)
    contact_phone = models.CharField(max_length=20)
    email = models.EmailField()
    # status = models.CharField(max_length=20, choices=STATUS_CHOICES)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    customer_type = models.CharField(max_length=50, choices=CUSTOMER_TYPE_CHOICES)

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='customers')

    # resources = models.ManyToManyField(Resource, through='CustomerResource', related_name='customers')

    def __str__(self):
        return self.customer_name

    class Meta:
        db_table = 'customer'
        ordering = ['-created_at']

class Resource(models.Model):

    RESOURCE_TYPE_CHOICES = [
        ('database', 'Database'),
        ('compute', 'Compute'),
        ('storage', 'Storage'),
        ('network', 'Network'),
    ]
    STATUS_CHOICES = [
        ('available', 'Available'),
        ('in_use', 'In Use'),
        ('maintenance', 'Maintenance')
    ]
    
    resource_name = models.CharField(max_length=100)
    resource_type = models.CharField(max_length=50, choices=RESOURCE_TYPE_CHOICES)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES)
    capacity = models.CharField(
        max_length=100,
        help_text="Specify resource capacity (e.g., 4 vCPUs, 100 GB, 1 TB bandwidth)."
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    server= models.ForeignKey(Servers, on_delete=models.CASCADE, related_name='server_resources')
    
    user= models.ForeignKey(User, on_delete=models.CASCADE, related_name='user_resources')
    customers = models.ManyToManyField(Customer, through='CustomerResource', related_name='customer_resources')

    def __str__(self):
        return self.resource_name

    class Meta:
        db_table = 'resource'

class CustomerResource(models.Model):
    PAYMENT_STATUS_CHOICES = [
        ('paid', 'Paid'),
        ('unpaid', 'Unpaid'),
        ('pending', 'Pending'),
    ]

    customer = models.ForeignKey(Customer, on_delete=models.CASCADE, related_name='customer_resources')
    resource = models.ForeignKey(Resource, on_delete=models.CASCADE, related_name='customer_resources')

    total_cost = models.DecimalField(max_digits=10, decimal_places=2, help_text="Total cost of the resource usage.")
    usage_start_date = models.DateTimeField(help_text="Start date of resource usage.")
    usage_end_date = models.DateTimeField(help_text="End date of resource usage.")
    payment_status = models.CharField(max_length=20, choices=PAYMENT_STATUS_CHOICES, default='pending')

    # created_at = models.DateTimeField(auto_now_add=True)
    # updated_at = models.DateTimeField(auto_now=True)

    @property
    def duration(self):
        """Calculate duration dynamically instead of storing it as an integer."""
        return (self.usage_end_date - self.usage_start_date).days

    def __str__(self):
        return f"{self.customer.customer_name} - {self.resource.resource_name}"

    class Meta:
        db_table = 'customer_resource'
        constraints = [
            models.UniqueConstraint(fields=['customer', 'resource'], name='unique_customer_resource')
        ]

class Hardware(models.Model):

    TYPE_CHOICES = [
    ('laptop', 'Laptop'),
    ('desktop', 'Desktop'),
    ('server', 'Server'),
    ('workstation', 'Workstation'),
    ('router', 'Router'),
    ('switch', 'Switch'),
    ('modem', 'Modem'),
    ('firewall', 'Firewall'),
    ('access_point', 'Access Point'),
    ('nas', 'NAS (Network Attached Storage)'),
    ('san', 'SAN (Storage Area Network)'),
    ('printer', 'Printer'),
    ('scanner', 'Scanner'),
    ('photocopier', 'Photocopier'),
    ('ups', 'UPS (Uninterruptible Power Supply)'),
    ('pdu', 'Power Distribution Unit'),
    ('cooling_unit', 'Cooling Unit'),
    ('kvm_switch', 'KVM Switch'),
    ('voip_phone', 'VoIP Phone'),
    ('iot_device', 'IoT Device'),
    ('other', 'Other'),
    ]

    STATUS_CHOICES = [
        ('active', 'Active'),
        ('inactive', 'Inactive'),
        ('maintenance', 'Maintenance')
    ]
    
    hardware_name = models.CharField(max_length=100)
    hardware_type = models.CharField(max_length=50, choices=TYPE_CHOICES)
    manufacturer = models.CharField(max_length=255)
    model_number = models.CharField(max_length=255)
    serial_number = models.CharField(max_length=100, unique=True)
    assigned_dept = models.CharField(max_length=255)

    # resource = models.ForeignKey(Resource, on_delete=models.CASCADE, related_name='devices')
    
    status = models.CharField(max_length=50, choices=STATUS_CHOICES)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_deleted = models.BooleanField(default=False)
    deleted_at = models.DateTimeField(null=True, blank=True)

    user= models.ForeignKey(User, on_delete=models.CASCADE, related_name='hardware')

    def __str__(self):
        return f"{self.hardware_name} ({self.serial_number})"

    class Meta:
        db_table = 'hardware'

class Warranty(models.Model):
    warranty_provider = models.CharField(max_length=50)
    # warranty_status = models.CharField(max_length=20, choices=STATUS_CHOICES)
    warranty_start_date = models.DateTimeField()
    original_warranty_duration = models.TextField()
    extended_warranty= models.BooleanField()
    extended_period = models.TextField()

    # derived field
    warranty_expiry_date = models.DateTimeField()

    hardware = models.OneToOneField(Hardware, on_delete=models.CASCADE, related_name="warranty")

    def __str__(self):
        return f"{self.warranty_type} - {self.customer.customer_name}"

    class Meta:
        db_table = 'warranty'
        verbose_name_plural = 'warranties'

class purchase(models.Model):
    purchase_date = models.DateTimeField()
    purchase_cost = models.DecimalField(max_digits=10, decimal_places=2)
    purchase_type = models.CharField(max_length=50)
    # supplier_name
    purchase_from = models.CharField(max_length=255)
    supplier_contact = models.CharField(max_length=20, blank=True, null=True)
    hardware = models.OneToOneField(Hardware, on_delete=models.CASCADE, related_name="purchase")

    def __str__(self):
        return f"{self.hardware.hardware_name} - {self.purchase_cost}"

    class Meta:
        db_table = 'purchase'
        verbose_name_plural = 'purchases'

class HardwareService(models.Model):
    STATUS_CHOICES = [
        ('active', 'Active'),
        ('completed', 'Completed'),
        ('pending', 'Pending'),
        ('cancelled', 'Cancelled')
    ]
    
    service_provider = models.CharField(max_length=50)
    service_provider_contact = models.CharField(max_length=100)
    service_cost = models.CharField(max_length=20, choices=STATUS_CHOICES)
    last_service_date = models.DateField(blank=True, null=True)
    no_of_services_done= models.IntegerField()
    no_of_free_services = models.IntegerField()
    service_period = models.CharField(max_length=50)
    free_services_used = models.IntegerField()
    free_service_date= models.DateTimeField()
    
    hardware= models.OneToOneField(Hardware, on_delete=models.CASCADE, related_name="service")

    @property
    def next_service_date(self):
        if self.last_service_date and self.service_period:
            return self.last_service_date + timedelta(days=self.service_period)
        return None  # If data is missing, return None
    
    def is_free_service_exhausted(self):
        """Returns True if all free services have been used."""
        return self.free_services_used >= self.total_no_of_free_service

    def __str__(self):
        status = "Exhausted" if self.is_free_service_exhausted() else "Available"
        return f"Free Service for {self.hardware.hardware_name} ({status})"

    def __str__(self):
        return self.service_name

    class Meta:
        db_table = 'service'

class Reminder(models.Model):
    REMINDER_TYPE_CHOICES = [
        ('renewal', 'Renewal'),
        ('maintenance', 'Maintenance'),
        ('custom', 'Custom'),
    ]

    REMINDER_STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('sent', 'Sent'),
        ('cancelled', 'Cancelled'),
    ]

    NOTIFICATION_METHOD_CHOICES = [
        ('email', 'Email'),
        ('sms', 'SMS'),
        ('both', 'Both'),
    ]

    REMINDER_FREQUENCY_CHOICES = [
        ('once', 'Once'),
        ('daily', 'Daily'),
        ('weekly', 'Weekly'),
        ('monthly', 'Monthly'),
    ]

    # subscription = models.ForeignKey('Subscription', on_delete=models.CASCADE, related_name='reminders', blank=True, null=True)
    # hardware = models.ForeignKey('Hardware', on_delete=models.CASCADE, related_name='reminders', blank=True, null=True)
    # customer = models.ForeignKey('Customer', on_delete=models.CASCADE, related_name='reminders', blank=True, null=True)

    reminder_type = models.CharField(max_length=50, choices=REMINDER_TYPE_CHOICES, default='renewal')
    reminder_days_before = models.IntegerField(default=7, help_text="Days before the due date to send a reminder.")
    reminder_date = models.DateField(help_text="Date when the reminder will be sent.")
    reminder_time = models.TimeField(default="09:00:00", help_text="Time to send the reminder.")
    reminder_status = models.CharField(max_length=50, choices=REMINDER_STATUS_CHOICES, default='pending')

    reminder_frequency = models.CharField(max_length=50, choices=REMINDER_FREQUENCY_CHOICES, default='once', help_text="Frequency of the reminder.")
    monthly_reminder_schedule = models.PositiveIntegerField(blank=True, null=True, help_text="Day of the month to send a monthly reminder (1-31).")

    notification_method = models.CharField(max_length=50, choices=NOTIFICATION_METHOD_CHOICES, default='email', help_text="How the reminder is sent.")
    sent_to = models.EmailField(blank=True, null=True, help_text="Primary email for sending the reminder.")
    custom_message = models.TextField(blank=True, null=True, help_text="Custom message for the reminder.")

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"Reminder ({self.reminder_type}) for {self.subscription or self.hardware or self.customer}"

    @classmethod
    def create_reminder_for_subscription(cls, subscription):
        """Create a reminder for a subscription based on its settings."""
        reminder_date = subscription.calculate_reminder_date()
        return cls.objects.create(
            subscription=subscription,
            reminder_date=reminder_date,
            sent_to=subscription.reminder_email
        )

class ReminderSubscription(models.Model):
    reminder = models.ForeignKey(Reminder, on_delete=models.CASCADE)
    subscription = models.ForeignKey('Subscription', on_delete=models.CASCADE)

class ReminderHardware(models.Model):
    reminder = models.ForeignKey(Reminder, on_delete=models.CASCADE)
    hardware = models.ForeignKey('Hardware', on_delete=models.CASCADE)

class ReminderCustomer(models.Model):
    reminder = models.ForeignKey(Reminder, on_delete=models.CASCADE)
    customer = models.ForeignKey('Customer', on_delete=models.CASCADE)

